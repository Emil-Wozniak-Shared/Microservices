import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardOpenOption

import static java.nio.file.StandardOpenOption.APPEND

//file:noinspection GroovyAssignabilityCheck
plugins {
    id "java-library"
    id "maven-publish"
    id("org.springframework.boot") version "2.5.5"
    id("io.spring.dependency-management") version "1.0.11.RELEASE"
    id "org.jetbrains.kotlin.jvm" version "1.5.31"
    id "org.jetbrains.kotlin.plugin.spring" version "1.5.31"
    id("org.openapi.generator") version "5.2.1"
}

group = "pl.emil"
version = "0.0.1-SNAPSHOT"
sourceCompatibility = 11
targetCompatibility = 11
project.ext {
    // API client version
    clientVersion = '1.0.1'
}

repositories {
    mavenLocal()
    mavenCentral()
}

def springdoc(target, version = "1.5.11") {
    dependencies {
        implementation("org.springdoc:springdoc-openapi-$target:$version")
    }
}

dependencies {
    springdoc("kotlin")
    springdoc("webflux-ui")
    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8")
    testImplementation("org.springframework.boot:spring-boot-starter-test")
}

tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach {
    kotlinOptions {
        freeCompilerArgs = ["-Xjsr305=strict"]
        jvmTarget = "11"
    }
}

test {
    useJUnitPlatform()
}

openApiGenerate {
    verbose = false
    generatorName = "kotlin"
    groupId = "pl.emil"
    packageName = "contract"
    inputSpec = "$rootDir/src/main/resources/api.json".toString()
    outputDir = "$buildDir/generated".toString()
    apiPackage = "pl.emil.contract.api"
    invokerPackage = "pl.emil.contract.invoker"
    modelPackage = "pl.emil.contract.model"
    configOptions = [dateLibrary: "java8"]
    generateModelTests = true
    generateApiTests = true
    version = "${project.clientVersion}"
    logToStderr = true
    configOptions = [
            dateLibrary: "java8"
    ]
    globalProperties = [
            modelDocs: "true"
    ]
}

java {
    withJavadocJar()
    withSourcesJar()
}

publishing {
    publications {
        maven(MavenPublication) {
            artifactId = 'contract-api'
            from components.java
            versionMapping {
                usage("java-api") {
                    fromResolutionOf("runtimeClasspath")
                }
                usage("java-runtime") {
                    fromResolutionResult()
                }
            }
            pom {
                name = "Microservice Commons"
                url = "http://localhost:8080/"
                developers {
                    developer {
                        id = "e.wozniak"
                        name = "Emil Woźniak"
                        email = "emil.wozniak.2020@gmail.com"
                    }
                }
            }
        }
        // @see: https://docs.gradle.org/current/userguide/publishing_maven.html
        contract(MavenPublication) {
            version "${clientVersion}"
            groupId = 'pl.emil'
            artifactId = 'contract'
            artifact("./build/generated/build/libs/kotlin-client-${project.clientVersion}.jar")
            versionMapping {
                usage("java-api") {
                    fromResolutionOf("runtimeClasspath")
                }
                usage("java-runtime") {
                    fromResolutionResult()
                }
            }
            pom {
                name = "Microservice Commons"
                url = "http://localhost:8080/"
                developers {
                    developer {
                        id = "e.wozniak"
                        name = "Emil Woźniak"
                        email = "emil.wozniak.2020@gmail.com"
                    }
                }
            }
        }
    }
    repositories {
        maven {
            url = (version.toString().endsWith("SNAPSHOT"))
                    ? uri(layout.buildDirectory.dir("repos/snapshots"))
                    : uri(layout.buildDirectory.dir("repos/releases"))
        }
    }
}

javadoc {
    if (JavaVersion.current().isJava9Compatible()) {
        options.addBooleanOption('html5', true)
    }
}

gradle.taskGraph.afterTask { Task task, TaskState state ->
    if (state.failure) {
        println "${task.getName()} failed"
    } else {
        println "${task.getName()} done"
    }
}
task openApi(type: GradleBuild) {
    try {
        println ">> Create API"
        buildFile ".${File.separator}build.gradle"
        tasks = ['clean', 'openApiGenerate']
    } catch (e) {
        e.printStackTrace()
    }
}

task buildApi(type: GradleBuild) {
    try {
        dependsOn(openApi)
        println ">> Build API"
        def apiBuildFile = "build${File.separator}generated${File.separator}build.gradle"
        def target = "${buildDir}${File.separator}generated${File.separator}build.gradle"
        println "Target: $target"
        try {
            Files.write(
                    Paths.get(target),
                    " java { withSourcesJar() } ".getBytes(),
                    APPEND);
        } catch (IOException e) {
            System.err.println(e);
        }
        println "  * execute build in $apiBuildFile file"
        buildFile ".${File.separator}build${File.separator}generated${File.separator}build.gradle"
        dir = ".${File.separator}build${File.separator}generated${File.separator}"
        tasks = ['build', 'jar']
        println "buildApi finished"
    } catch (e) {
        e.printStackTrace()
    }
}

task publishApi() {
    try {
        assert project.clientVersion != null: "You must have API client version set to not null"
        dependsOn(buildApi)
        finalizedBy(publishToMavenLocal)
        println "<< Publish"
        println "  * Publish pl.emil:contract:${project.clientVersion}"
    } catch (e) {
        e.printStackTrace()
    }
}

task createApiAndPublish(type: GradleBuild) {
}
